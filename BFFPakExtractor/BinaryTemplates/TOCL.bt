//------------------------------------------------
//--- 010 Editor v11.0.1 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

LittleEndian();
BitfieldDisablePadding();

typedef struct 
{
    int off;

    int PakSize <format=hex, fgcolor=cGreen>;
    int PakOffset <format=hex, fgcolor=cRed>;
    int testtt;
    char Name[0x100];

} PakInfo;

// 0x130 

typedef struct 
{
    int Auto : 11;
    int Interim : 11;
    byte Minor : 6;
    byte Major : 4;
} BVersion;

local string pakTag = "PAK ";

typedef struct
{
    int64 Uid <format=hex>;
    int64 Offset;
    int PakSize;
    int FileSize;
    int File;
    int PakFile;
    short Flags <format=hex>;
    uint crc32;
    char Extension[4];
} PakFileTocEntry;

typedef struct
{
    local int cPos = FTell();
    struct PakFileHeader
    {
        char mID[4];
        BVersion Version;

        int nAssets;
        int d;
        int e;
        int f;
        char Name[0x100];
        int PakFileTocEntrySize <format=hex>;
        int mCRCSize;
        int ExtInfoSize <format=hex>;
        int y;
        int z;
        byte mBigEndian;
        enum <byte> ePakFileEncryption { None, TwoFish, RC4 } EncryptionFlags;
        byte flag3;
        byte flag4;
    } header;
 
    PakFileTocEntry infos[header.nAssets];

    if (header.ExtInfoSize != 0)
    {
        struct ExtInfoTable
        {
            byte extHeader[0x308]; // Always 0x308, must be
            local int i = 0;
            struct ExtInfo
            {
                int NameOffset <format=hex, fgcolor=cRed>;
                int b;
                int c;
                int d;
                
                if (header.EncryptionFlags == 0)
                {
                    local int tmp = FTell();
                    FSeek(cPos + NameOffset);
                    byte nLen;
                    char Name[nLen];
                    FSeek(tmp);
                }
            } ExtInf[header.nAssets] <optimize=false>;
        } ExtInfoTbl;
    }
    

} Pak <optimize=false>;

struct ToC
{
    
    struct Header
    {
        char Magic[4];
        int a;
        int count;
        int c;
    } header;

    PakInfo pakInfos[header.count];

    local int i = 0;
    for (i = 0; i < header.count; i++)
    {
        FSeek(pakInfos[i].PakOffset);
        Pak pak;
    }
} LCOT;